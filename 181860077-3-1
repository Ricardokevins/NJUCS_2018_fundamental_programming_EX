#include<iostream>
#include<cstdlib>
using namespace std;
#define max 18
//使用了桶来保存数据，免除了排序，也节约了空间
//3-10是正常的数据，JQK是11-13，A是14，2是15，最后的是大小王
void mygetnum(char *A, int *B)
{
	for (; *A != '\0'; A++)
	{
		if (*A <= '9'&&*A >= '3')
		{
			int j = *A - '0';
			B[j]++;
			A++;
			continue;

		}
		if (*A == '1'&&*(A + 1) == '0')
		{
			int j = 10;
			B[j]++;
			A += 2;
		}
		if (*A == 'J'&&*(A + 1)!='O')
		{
			int j = 11;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'Q')
		{
			int j = 12;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'K')
		{
			int j = 13;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'A')
		{
			int j = 14;
			B[j]++;
			A++;
			continue;
		}
		if (*A =='2')
		{
			int j =15;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'j'&&*(A + 1) == 'o')
		{
			int j = 16;
			B[j]++;
			A += 4;
			continue;
		}
		if (*A == 'J'&&*(A + 1) == 'O'&&*(A + 2) == 'K')
		{
			int j = 17;
			B[j]++;
			A += 4;
			continue;
		}
	}
}
//写了一个找到桶里的最多牌数并返回大小的函数
int findmax(int *B,int *num)//num就是张数，返回的是牌的值
{
	int pos(3);
	for (int i(3); i < max; i++)
	{
		if (B[i] > B[pos])
		{
			pos = i;
		}
	}
	*num = B[pos];
	return pos;
}
int findit(int *B,int p)//这个函数是为了找到特定的数目的张数，返回值是这个牌的值，如果返回-1就是没有找到
{
	for (int i(3); i < max; i++)
	{
		if (B[i] == p)
		{
			return i;
		}
	}
	return -1;
}
//解析对手的牌
void jiexi(char *A, int *type, int *cardm,int* q,int *p)//type保存的是牌的种类，cardm保存的是牌的数值（最小的），q是带的张数（种类，一张还是一对的），p是连续的张数。
{
	int B[18] = {};
	B[0] = 0;
	B[1] = 0;
	B[2] = 0;
	mygetnum(A,B);
	int allnum(0);
	//计算对方的出牌数
	int initmax1(0);
	int initmax2 = findmax(B, &initmax1);
	if (initmax1 == 1)//顺子的可能性
	{
		if (B[16] == 1 && B[17] == 1)
		{
			*type = 41;
			return;
		}
		int singlenum(0);
		for (int i(3); i < max; i++)
		{
			if (B[i] == 1)
			{
				singlenum++;
			}
		}
		if (singlenum != 1)
		{
			*type = 7;
			*p = singlenum;
			*cardm = initmax2;
			return;
		}

	}
	if (initmax1 == 2)//排除连对的可能性
	{
		int doublenum(0);
		for (int i(3); i < max; i++)
		{
			if (B[i] == 2)
			{
				doublenum++;
			}
		}
		if (doublenum != 1)
		{
			*type = 8;
			*p = doublenum;
			*cardm = initmax2;
			return;
		}
	}
	for (int i(3); i < max; i++)//计算总的牌数
	{
		allnum += B[i];
	}
	if (allnum == 1)
	{
		*type = 1;
		int k(0);
		*cardm = findmax(B, &k);
		return;
	}
	if (allnum == 2)
	{
		*type = 2;
		int k(0);
		*cardm = findmax(B, &k);
		return;
	}
	if (allnum == 3)
	{
		*type = 3;
		int k(0);
		*cardm = findmax(B,&k);
		*q = 0;
		return;
	}
	if (allnum == 4)
	{
		int maxnumzhang = 0;
		int maxnumzhi=findmax(B,&maxnumzhang);
		if (maxnumzhang == 4)
		{
			*type = 4;
			*cardm = maxnumzhi;
			return;
		}
		if (maxnumzhang == 3)
		{
			*type = 3;
			*cardm = maxnumzhi;
			*q = 1;
			return;
		}
	}
	if (allnum == 5)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三带二
		{
			*type = 3;
			*cardm = maxnumzhi;
			*q = 2;
			return;
		}
	}
	if (allnum == 6)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//飞机不带
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 0;
			*p = 2;
			return;
		}
		if (maxnumzhang == 4)//四带二
		{
			*type = 5;
			*cardm = maxnumzhi;
			*q = 1;
			return;
		}
	}
	if (allnum == 8)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//飞机带一
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 1;
			*p = 2;
			return;
		}
		if (maxnumzhang == 4)//四带二对
		{
			*type = 5;
			*cardm = maxnumzhi;
			*q = 2;
			return;
		}
	}
	if (allnum == 9)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机不带
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 0;
			*p = 3;
			return;
		}
	}
	if (allnum == 10)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//二飞机带两对
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 2;
			*p = 2;
			return;
		}
	}
	if (allnum == 12)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机带一
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 1;
			*p = 3;
			return;
		}
	}
	if (allnum == 15)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机带二
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 2;
			*p = 3;
			return;
		}
	}

}
//对于对手不同的出牌的模式进行思考
//编号为第一种，单张
int singlecard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 0)
		{
			cout << i << endl;
			cardnum[i]--;
			return i;
		}
	}
	return -1;
}
//编号为第二种，对子
int doublecard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 1)
		{
			cout << i << " " << i << endl;
			cardnum[i] -= 2;
			return i;
		}
	}
	return -1;
}
//编号为第三种，三张
int triblecard(int *cardnum, int q, int p)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 2)
		{
			if (p == 0)
			{
				cout << i << " " << i << " " << i << " " << endl;
				cardnum[i] -= 3;//张数减少避免可能的牌重复出
				return i;
			}
			for (int j(3); j < max; j++)
			{
				if (cardnum[j] >= p)
				{
					if (p == 1)
					{
						cout << i << " " << i << " " << i << " " << j << endl;
						cardnum[j]--;
					}

					else
					{
						cout << i << " " << i << " " << i << " " << j << " " << j << endl;
						cardnum[j] -= 2;
					}
					return 1;
				}
			}
			cardnum[i] += 3;//组合失败就重新回去计算
		}

	}
	return -1;
}
//第四，炸弹
int bombcard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] == 4)
		{
			for (int j(0); j < 4; j++)
			{
				cout << i << " ";
			}
			cout << endl;
			cardnum[i] -= 4;
			return i;
		}
	}
	if (cardnum[16] == 1 && cardnum[17] == 1)
	{
		cardnum[16]--; 
		cardnum[17]--;
		cout << "Rocket!!!" << endl;
		return 0;
	}
	return -1;
}
//第五，四带二
int forthcard(int *cardnum, int q, int p)
{
	for (int i(q + 1); i < max; i++)
	{
		if (cardnum[i] == 4)
		{
			for (int j(3); j < max; j++)
			{
				if (cardnum[j] >= p)
				{
					if (p == 1)
					{
						cout << i << " " << i << " " << i << " " << i << " " << j << endl;
						cardnum[j] -= 1;
						cardnum[i] -= 4;
					}
					else
					{
						cout << i << " " << i << " " << i << " " << i << " " << j << " " << j << endl;
						cardnum[j] -= 1;
						cardnum[i] -= 4;
					}
					return 1;
				}
			}
			return -1;
		}
	}
}
//第六，飞机
int planecard(int *cardnum, int q,int p,int s)//仍然是q代表的是三的最小的起点，然后后面表示的是带的张数，最后是飞机的连续数目
{
	for (int i(q); i < max - s + 1; i++)
	{
		int k(0);
		for (; k < s; k++)//从当前的起点开始向后面找s个数值的牌是否也是飞机
		{
			if (cardnum[i + k] < 3)
				break;
		}
		if (k == s)
		{
			for (int shu(0); shu < s; shu++)
			{
				cardnum[i + shu] -= 3;
			}
			if (s == 2)
			{

			}
			for (int w(3); w < max; w++)
			{
				if()
			}
			for (int shu(0); shu < s; shu++)
			{
				cout<<i+shu<<" "<<i+shu<<" "<<i+shu<<
			}
		}

		
	}
	return 0;
}
//第七，顺子
int shunzi(int *cardnum, int q, int p)
{
	return 0;
}
//第八，连对
int doubleshunzi(int *cardnum, int q, int p)
{
	return 0;
}
int main()
{
	//A是输入的我的牌
	char A[100] = {};
	A[0] = getchar();
	int i(0);
	for (; A[i] != '\n';)
	{
		i++;
		A[i] = getchar();
		
	}
	A[i] = '\0';
	//B是对我的手牌进行转化为数字
	int B[18] = {};
	B[0] = 0;
	B[1] = 0;
	B[2] = 0;
	mygetnum(A, B);
	int j(1);
	//调试0
	/*
	for (int s(3); s < 18; s++)
	{
		cout << s << "\t";
	}
	cout << endl;
	for (int j(3); j<18; j++)
	{
		cout << B[j] <<"\t";
	}
	cout << endl;
	
	if (singlecard(B, 3) == -1)  cout << -1 << endl;
	if (doublecard(B, 3) == 1) cout << -1 << endl;
	if (triblecard(B, 3, 2) == -1) cout << -1 << endl;
	if (bombcard(B, 5)== -1) cout << -1 << endl;
	if (forthcard(B, 3, 2) == -1) cout << -1 << endl;
	for (int j(3); j < 18; j++)
	{
		cout << B[j] << "\t";
	}
	cout << endl;
	return 0;
	
	int mynum(0);
	cout << findmax(B,&mynum)<<endl;
	cout << mynum;
	*/
	//测试解析函数
	int type = 0;
	int cardm = 0;
	int q = 0;
	int p = 0;
	jiexi(A, &type, &cardm, &q, &p);
	cout << type << endl;//手牌种类
	cout << cardm << endl;//手牌起始值
	cout << q << endl;//带的张数种类
	cout << p << endl;//连续的数目

}
